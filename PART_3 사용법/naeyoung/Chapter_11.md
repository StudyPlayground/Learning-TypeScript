# CHAPTER 11 선언 파일

타입스크립트 프로젝트에서 원시 자바스크립트 파일로 작업할 수 있어야 한다. 많은 패키지가 타입스크립트가 아닌 자바스크립트로 직접 작성되고, 타입스크립트로 작성된 패키지조차도 자바스크립트 파일로 배포된다. 

게다가 타입스크립트 프로젝트는 전역변수와 API 같은 환경에 특화된 기능의 타입 형태를 알려주는 방법이 필요하다. 예를 들어 Node에서 실행되는 프로젝트는 브라우저에서 사용할 수 없는 내장 Node.JS 모듈에 접근할 수 있으며 그 반대도 마찬가지이다.

타입스크립트는 구현과 별도로 타입 형태를 선언할 수 있다. 타입 선언은 파일 이름이 .d.ts 확장자로 끝나는 선언 파일에 작성된다. 선언 파일은 일반적으로 프로젝트 내에서 작성되고, 프로젝트의 컴파일된 npm 패키지로 빌드 및 배포되거나 독립 실행형 typings 패키지로 공유된다. 

## 11.1 선언 파일

.d.ts 선언 파일은 런타임 코드를 포함할 수 없다는 주목할만한 제약 사항을 제외하고는 .ts 파일과 유사하게 작동한다. .d.ts파일에는 사용 가능한 런타임 값, 인터페이스, 모듈, 일반적인 타입의 설명만 포함된다. 

선언 파일은 다른 타입스크립트 파일과 마찬가지로 임포트해서 사용할 수 있다. 

선언 파일은 값이 아닌 타입만 선언할 수 있는 코드 영역을 의미하는 앰비언트 컨텍스트를 생성합니다. 

<aside>
💡 선언 파일은 값이 아닌 타입만 선언할 수 있는 코드 영역을 의미하는 **앰비언트 컨텍스트**를 생성한다.

</aside>

## 11.2 런타임 값 선언

**비록 선언 파일은 함수 또는 변수 같은 런타임 값을 생성하지 않을 수 있지만 declare 키워드를 사용해 이러한 구조체가 존재한다고 선언할 수 있다.** 이렇게 하면 **웹 페이지의 <script> 태그 같은 일부 외부 작업이 특정 타입의 이름을 사용해 값을 생성했음을 타입 시스템에 알린다.**

declare로 변수를 선언하면 초깃값이 허용되지 않는다는 점을 제외하고 일반적인 변수 선언과 동일한 구문을 사용한다. 

```tsx
declare let declared: string // OK
declare let initializer : string = "Wanda";
// Error: Initializers are not allowed in ambient contexts(엠비언트 컨텍스트)
```

함수와 클래스도 일반적인 형식과 유사하게 선언되지만 함수 또는 메서드의 본문이 없다.

<aside>
💡 타입스크립트의 암시적 any 타입의 규칙은 **일반 소스 코드**와 마찬가지로 **앰비언트 컨텍스트에 선언된 함수와 변수에 대해 동일하게 작동한다.** 앰비언트 컨텍스트는 함수 본문이나 초기 변숫값을 제공하지 않을 수 있으므로 **명시적 타입 애너테이션은 일반적으로 any 타입이 되는 것을 막을 유일한 방법이다.**

</aside>

declare 키워드를 사용한 타입 선언은 .d.ts 선언 파일에서 사용하는게 가장 일반적이지만, 선언 파일 외부에서도 사용할 수 있다. 모듈 또는 스크립트 파일에서도 declare 키워드를 사용할 수 있다. **전역으로 사용가능한 변수가 해당 파일에서만 사용되어야하는 경우 declare 키워드가 유용하다.**

인터페이스와 같은 타입 형태는 .d.ts 선언 파일에서 declare 키워드 유무와는 관계없이 허용되지만, 함수나 변수 같은 런타임 구문에 declare 키워드가 없다면 타입 오류가 발생한다. 

### 11.2.1 전역 변수

import 또는 export 문이 없는 타입스크립트 파일은 모듈이 아닌 스크립트로 취급되기 때문에 **여기에 선언된 타입을 포함한 구문은 전역으로 사용된다.** 

⇒ TS의 고유 기능이 아니라 js 동작 원리에 따른 것. 

import 또는 export 가 없는 선언 파일은 해당 동작의 이점을 사용해 타입을 전역으로 사용할 수 있다. 전역 선언 파일은 애플리케이션의 모든 파일에 걸쳐 사용할 수 있는 전역 타입 또는 변수를 선언하는데 특히 유용하다.

전역으로 선언된 값은 전역 변수를 사용하는 브라우저 애플리케이션에서 가장 자주 사용된다.

대부분의 최신 웹 프레임워크는 일반적으로 ECMA스크립트 모듈 같은 최신 기술을 사요하지만, 변수를 전역으로 저장하는 작업은 특히 작은 프로젝트에서는 여전히 유용하다. 

### 11.2.2 전역 인터페이스 병합

변수는 타입스크립트 타입 시스템에서 돌아다니는 유일한 전역은 아니다. 전역 API와 값에 대한 많은 타입 선언이 전역으로 존재한다. **인터페이스는 동일한 이름의 다른 인터페이스와 병합하기 때문에 import와 export 문이 없는 .d.ts 선언 파일같은 전역 스크립트 컨텍스트에서 인터페이스를 선언하면 해당 인터페이스가 전역으로 확장된다.** 

예를 들어 서버에 따라 설정된 전역 변수에 의존하는 웹 어플리케이션은 해당 변수를 전역 Window 인터페이스에 존재하도록 선언하고 싶을 수 있다. 인터페이스 병합을 이용하면 window 변수에 존재하는 변수를 선언할 수 있도록 허용한다. 

```tsx
window.myVersion = "3.1.1";

// d.ts 파일
interface Window {
	myVersion : string;
}
```

### 11.2.3 전역 확장

다른 곳에 정의된 타입을 가져와 전역 정의를 크게 단순화할 때와 같이 전역 범위로 확장이 필요한 .d.ts 파일에 import 또는 export 문을 항상 금지할 수 있는 것은 아니다. 

**경우에 따라 모듈 파일에 선언된 타입이 전역으로 사용되어야 한다.**

타입스크립트에서 declare global 코드 블록 구문을 사용해 해당 블록 내용이 전역 컨텍스트에 있다고 표시할 수 있다. 

```tsx
// types.d.ts
// 모듈 컨텍스트
declare global {
	 // 전역 컨텍스트
}
// (모듈 컨텍스트)
```

다음 types/data.d.ts 파일은 Data 인터페이스를 내보내고, 나중에 types/global.d.ts와 런타임 index.ts 파일에서 이 인터페이스를 가져온다. 

```tsx
export interface Data {
	version : string;
}
```

또한 types/globals.d.ts 파일에서만 사용할 수 있는 변수와 Data 타입 변수를 declare global 블록 내에 전역으로 선언한다. 

```tsx
import { Data } from "./data";

declare global {
	const globallyDeclared : Data;
}
```

## 11.3 내장된 선언

Array, Function, Map, Set과 같은 전역 객체는 타입 시스템이 알아야 하지만 코드에서 선언되지 않는 구문이다. 이와 같은 전역 객체는 타입시스템이 알아야 하지만 코드에서 선언되지 않는 구문이다. 이와 같은 전역 **객체는 디노, Node.js, 웹 브라우저 등에서 실행되는 런타임 코드에 의해 제공된다.**

### 11.3.1 라이브러리 선언

모든 자바스크립트 런타임에 존재하는 Array, Function과 같은 내장된 전역 객체는 lib.[target].d.ts 파일 이름으로 선언된다. 여기에 **target은 ES5, ES2020 또는 ESNext와 같이 프로젝트에서 대상으로 하는 자바스크립트의 최소 지원 버전이다.** 

내장된 라이브러리 런타임에 존재하는 선언 파일 또는 ‘lib’ 파일은 자바스크립트의 내장된 API 전체를 나나태기 때문에 상당히 크다. 

lib 파일은 **타입스크립트 npm 패키지의 일부로 배포**되며 **node_modules/typescript/lib.es5.d.ts 와 같은 경로의 패키지 내부에서 찾을 수 있다.** 

### 라이브러리 target

**타입스크립트는 기본적으로 tsc CLI 또는 프로젝트의 tsconfig.json(기본값은 es5)에서 제공된 target 설정에 따라 적절한 lib 파일을 포함한다.** 자바스크립트 최신 버전에 대한 연속적인 lib 파일들은 **인터페이스 병합을 사용해 서로 빌드된다.** 

예를 들어 ES2015에 추가된 EPSILON.isFinite와 같은 정적 Number 멤버는 lib.es2015.d.ts에 나열된다. 

타입스크립트 프로젝트는 target으로 지정한 자바스크립트 버전의 모든 최소 버전 lib 파일을 포함한다. 예를 들어 target이 es2016인 프로젝트에는 lib.es5.d.ts, lib.es2015.d.ts, 그리고 lib.es2016.d.ts까지 포함된다.

<aside>
💡 target 보다 최신 버전의 자바스크립트에서만 사용할 수 있는 기능은 타입 시스템에서 사용할 수 없다. 예를 들어 target이 es5이면 String.prototype.startsWith와 같은 ES2015 이상의 기능은 인식되지 않는다.

</aside>

### 11.3.2 DOM 선언

자바스크립트 언어 자체 외에 가장 일반적으로 참조되는 타입 선언 영역은 웹 브라우저를 위한 것이다. DOM이라고도 한다. localStorage와 같은 API와 웹 브라우저에서 주로 사용하는 HTMLElement와 같은 타입 형태를 다룬다.

DOM 타입은 lib.dom.d.ts 파일과 다른 lib.*.d.ts 선언 파일에도 저장된다.

많은 내장 전역 타입처럼 전역 DOM 타입은 전역 인터페이스로 설명된다.

lib 커파일러 옵션을 재정의하지 않는 타입스크립트 프로젝트는 DOM 타입을 기본적으로 포함한다. 

### 11.4 모듈 선언

선언 파일의 또 다른 중요 기능은 모듈의 상태를 설명하는 기능이다. 모듈의 문자열 이름 앞에 declare 키워드를 사용하면 **모듈의 내용을 타입 시스템에 알릴 수 있다.**

```tsx
declare module "my-example-lib" {
	 export const value: string;
}
```

```tsx
import { value } from "my-example-lib" 
console.log(value)
```

코드에서 declare modure을 자주 사용해서는 안된다. decalre module은 주로 다음 절에 나오는 와일드카드 모듈 선언과 이 장의 후반부에서 다루는 패키지 타입과 함께 사용된다. 또한 타입스크립트가 .json 파일의 가져오기를 기본으로 인식하도록 설정하는 컴파일러 옵션인 resolveJsonModule가 있다. 

### 11.4.1 와일드카드 모듈 선언

모듈 선언은 **자바스크립트와 타입스크립트 파일 확장자가 아닌 특정 파일의 내용을 코드로 가져올 수 있음을 웹 애플리케이션에 알리기 위해 사용한다.** 모듈 선언으로 하나의 * 와일드 카드를 포함해 해당 패턴과 일치하는 모든 모듈을 나타낼 수 있다. 

예를 들어 cra와 create next app 같은 인기 있는 react starter에 미리 구성된 것 처럼 많은 웹 프로젝트는 css모듈을 지원하며 **css 파일에서 런타임에 사용할 수 있는 객체로 스타일을 가져온다.** 기본적으로 { [ i : string ] : string } 타입의 객체를 내보내는 “*.module.css”와 같은 패턴으로 모듈을 정의한다. 

```tsx
declare module "*module.css" {
	const styles : {[i : string] : string };
	export default styles;
}
```

```tsx
import styles from "./styles.module.css";
styles.anyClassName // 타입: STRING
```

<aside>
💡 와일드카드 모듈을 사용해 로컬 파일을 나타내는 방식이 타입 안정성을 완벽히 보장하지 않는다. 타입스크립트는 가져온 모듈 경로가 로컬 파일과 일치하는지 확인하는 메커니즘을 제공하지 않는다. 일부 프로젝트는 웹팩같은 빌드 시스템을 사용하거나 로컬 파일에서 .d.ts 파일을 생성해 가져오기가 가능한지 확인한다.

</aside>

## 11.5 패키지 타입

프로젝트 내에서 declare를 사용하는 방법을 살펴 봤고, 이제 **패키지 간 타입을 사용하는 방법**을 다루겠다. 타입스크립트로 작성된 프로젝트는 여전히 **.js로 컴파일된 파일이 포함한 패키지를 배포**한다. 일반적으로 .d.ts 파일을 사용해 자바스크립트 파일 뒤에 타입스크립트 타입 시스템 형태를 지원하도록 선언한다. 

### 11.5.1 선언

타입스크립트는 **입력된 파일에 대한 .d.ts 출력 파일과 자바스크립트 출력 파일을 함께 생성하는 선언 옵션을 제공한다.** 

```tsx
// index.ts

export const greet = (text: string) => {
	console.log(`Hello, ${text}!`)
}
```

출력 파일(es2015, target : es2015)

```tsx
// index.d.ts
export declare const greet: (text: string) => void;
```

```tsx
// index.js
export const greet= (text) => {
	console.log(`Hello, ${text}!`);
}
```

자동으로 생성된 .d.ts 파일은 프로젝트에서 사용자가 사용할 타입 정의를 생성하는 가장 좋은 방법이다. 일반적으로 .js 파일을 생성하는 타입스크립트로 작성된 대부분의 패키지도 해당 파일과 함께 .d.ts를 번들로 묶는 것이 좋다.

### 11.5.2 패키지 타입 의존성

타입스크립트는 프로젝트의 node_modules 의존성 내부에서 번들로 제공되는 .d.ts 파일을 감지하고 활용할 수 있다. 이러한 파일은 해당 패키지에서 내보낸 타입 형태에 대해 마치 동일한 프로젝트에서 작성되었거나 선언 모듈 블록으로 선언된 것 처럼 타입시스템에 알린다.

## 11.6 DefinitelyTyped

## 11.7 마치며
