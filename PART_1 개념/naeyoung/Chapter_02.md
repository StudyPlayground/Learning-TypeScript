## 2.1 타입의 종류

타입: 자바스크립트에서 다루는 값의 **형태**에 대한 설명

형태: 값에 존재하는 속성, 메서드, typeof 연산자가 설명하는 것

타입스크립트의 가장 기본적인 타입은 자바스크립트의 7가지 원시타입과 일치한다.

**JS의 7가지 원시 타입**

- null
- undefined
- boolean
- string
- number
- bigint
- symbol

<aside>
💡 자바스크립트 Boolen과 Number와 같은 객체는 각 원싯값을 감싸는 객체이다.

</aside>

### 2.1.1 타입시스템

타입시스템은 프로그래밍 언어가 프로그램에서 가질 수 있는 타입을 이해하는 방법에 대한 규칙 집합이다. 

기본적으로 타입스크립트의 타입 시스템은 다음과 같이 동작한다.

1. 코드를 읽고 존재하는 모든 타입과 값을 이해한다.
2. 각 값이 초기선언에서 가질 수있는 모든 타입을 확인한다. 
3. 각 값이 추후 코드에서 어떻게 사용될 수 있는지 모든 방법을 확인한다.
4. 값의 사용법이 타입과 일치하지 않으면 사용자에게 오류를 표시한다. 

### 2.1.2 오류 종류

타입스크립트를 작성하는 동안 자주 접하는 오류는 다음과 같다.

- 구문 오류: TS → JS로 변환되는 것을 차단한 경우
    - 구문 오류는 잘못된 구문이 있을 때 타입스크립트 파일에서 자바스크립트 파일을 올바르게 생성할 수 없도록 차단한다.
- 타입 오류: 타입 검사기에 따라 일치하지 않는 것이 감지된 경우
    - 타입스크립트 구문이 자바스크립트로 변환되는 것을 차단하지 않는다. 타입 오류가 있음에도 자바스크립트 코드를 출력할 수 있지만, 출력된 자바스크립트 코드가 원하는대로 실행되지 않을 가능성이 있다는 신호를 타입 오류로 알려준다.

## 2.2 할당 가능성

타입스크립트는 변수의 초깃값을 읽고 해당 변수가 허용되는 타입을 결정한다. 나중에 해당 변수에 새로운 값이 할당되면 새롭게 할당된 값의 타입이 일치하는지 확인한다. 이처럼 함수 호출이나 변수에 값을 제공할 수 있는지 여부를 확인하는 것을 **할당 가능성**이라고 한다.

## 2.3 타입 에너테이션

변수에 타입스크립트가 읽어야 할 초깃값이 없는 경우에 타입스크립트는 나중에 사용할 변수의 초기타입을 파악하려고 시도하지 않고 any로 간주한다.

초기타입을 유추할 수 없는 변수는 **진화하는 any**라고 부른다. *

```jsx
let x;
x = 1;
x = 'string';
x = true;
//에러가 나지 않는다.
```

일반적으로 any타입을 사용해 any타입으로 진화하는 것을 허용하게 되면 타입스크립트의 타입 검사 목적을 부분적으로 쓸모없게 만든다. 따라서 변수를 사용할 때에는 이 방법 대신, 초깃값을 할당하지 않고도 변수의 타입을 선언할 수 있는 구문인 **타입 애너테이션**을 사용한다. 

타입 에너테이션은 변수 이름 뒤에 배치되며, 콜론과 타입 이름을 차례대로 기재한다. 

```jsx
let x : number;
```

이러한 타입 애너테이션은 타입스크립트에만 존재하며 런타임 코드에 영향을 주지 않는다.

변수에 타입 애너테이션으로 정의한 타입 외의 값을 할당하면 타입 오류가 발생한다.

<aside>
💡 타입시스템에만 존재하는 것은 컴파일된 자바스크립트로 복사되지 않는다. 타입스크립트 타입은 컴파일을 통해 생성된 자바스립트에 어떠한 영향도 주지 않는다.

</aside>

### 2.3.1 불필요한 타입 애너테이션

타입 에너테이션은 타입스크립트가 자체적으로 수집할 수 없는 정보를 타입스크립트에게 제공할 수 있다. 수동으로 작성한 중복 적용은 수고로움이 크다. 

```jsx
let firstName : string = "Tina"
```

하지만 코드를 명확하게 문서화하거나 실수로 변수 타입이 변경되지 않도록 타입스크립트에 명시적으로 타입 애너테이션을 포함하는 것이 경우에 따라서는 유용할 수 있다. 

## 2.4 타입 형태

타입스크립트는 변수에 할당된 값이 원래 타입과 일치하는지 확인하는 것 이상을 수행한다. 객체의 형태에 대한 이해를 바탕으로 할당 가능성 뿐만 아니라 **객체 사용과 관련된 문제도 알려준다.** 

### 2.4.1 모듈

자바스크립트는 비교적 최근까지 서로 다른 파일에 작성된 코드를 공유하는 방법과 관련된 사양을 제공하지 않았다. ECMA스크립트 2015에는 파일간 가져오고, 내보내는 구문을 표준화하기 위해 ECMAscript 모듈이 추가되었다. 

모듈: export 또는 import가 있는 파일

스크립트: 모듈이 아닌 모든 파일

타입스크립트는 최신 모듈 파일을 기존 파일과 함께 실행할 수 있다. 모듈 파일에 선언된 모든 것은 해당 파일에서 명시한 export 문에서 내보내지 않는 한 모듈 파일에서만 사용할 수 있다.

 한 모듈에서 다른 파일에 선언된 변수와 동일한 이름으로 선언된 변수는 다른 파일의 변수를 가져오지 않는 한 이름 충돌로 간주되지 않는다. 

반면 파일이 스크립트라면 타입스크립트는 해당 파일을 전역스코프로 간주하기 때문에, 모든 스크립트가 파일의 내용에 접근할 수 있다. 즉, 스크립트 파일에 선언된 변수는 다른 스크립트 파일에 선언된 변수와 동일한 이름을 가질 수 없다. 

- 스크립트 중복 선언 오류
   
   

만약 export 또는 import 문 없이 파일을 모듈로 만들어야 한다면, 파일의 아무 곳에나 export{}; 를 추가헤 강제로 모듈이 되도록 만든다. 

<aside>
💡 타입스크립트는 CommonnJS와 가은 이전 모듈을 사용해 작성된 타입 스크립트 파일의 import export 형태는 인식하지 못한다. 타입스크립트는 일반적으로 CommonJS스타일의 require 함수에서 반환된 값을 any로 인식한다.

</aside>
