## 4.1 객체 타입

{ … } 구문을 사용해 객체 리터럴을 생성하면, 타입스크립트는 해당 속성을 기반으로 새로운 객체 타입 또는 타입 형태를 고려한다. 해당 객체 타입은 객체의 값과 동일한 속성명과 원시 타입을 갖는다. 

### 4.1.1 객체 타입 선언

명시적으로 타입을 선언할 수 있다. 

```jsx
let poetLater : {
	born : number,
	name : string
}

poetLater = {
	born : 1935,
	name : "Mary Oliver"
}
```

### 4.1.2 별칭 객체 타입

타입 별칭을 할당해 사용하는 방식이 가장 일반적이다.

<aside>
💡 대부분의 타입스크립트 프로젝트는 객체 타입을 설명할 때 인터페이스 키워드를 사용하는 것을 선호합니다. 타입과 인터페이스는 거의 동일하므로 이 내용은 인터페이스에도 적용된다.

</aside>

## 4.2 구조적 타이핑

타입스크립트의 타입 시스템은 구조적으로 타입화되어 있다. 즉, 타입을 충족하는 모든 값을 해당 타입의 값으로 사용할 수 있다. 

매개변수나 변수가 특정 객체 타입이라면, 해당 속성이 있어야  한다.

구조적 타이핑은 덕타이핑과 다르다.

- 타입스크립트의 타입 검사기에서 구조적 타이핑은 정적 시스템이 타입을 검사하는 경우
- 덕타이핑은 런타임에서 사용될 때까지 객체 타입을 검사하지 않는 것.

자바스크립트는 덕 타입인 반면, 타입스크립트는 구조적으로 타입화된다.

### 4.2.1 사용 검사

객체 타입으로 애너테이션된 위치에 값을 제공할 때 타입스크립트는 값을 해당 객체 타입에 할당할 수 있는지 확인한다. 할당하는 값에는 객체 타입의 필수 속성이 있어야 하고, 타입이 같아야 한다.

### 4.2.2 초과 속성 검사

변수가 객체 타입으로 선언되고, 초깃값에 객체 타입에서 정의된 것 보다 **더 많은 필드가 있어도** 타입스크립트에서 타입 오류가 발생한다. 따라서 변수를 객체 타입으로 선언하는 것은 타입 검사기가 해당 타입에 예상되는 필드만 있는지 확인하는 방법이다.

```jsx
type Poet = {
	born : number;
	name : string;
}

const poetMatch: Poet = {
	born : 1928,
	name : "Maya Angelou"
}

const extraProperty : Poet = {
	activity : "walking", // error
	born : 1935,
	name : "Mary Oliver"
}
```

### 4.2.3 중첩된 객체 타입

자바스크립트 객체는 다른 객체의 멤버로 중첩될 수 있기 때문에 타입스크립트의 객체 타입도 타입 시스템에서 중첩된 객체 타입을 나타낼 수 있어야 한다. 이를 구현하는 구문은 이전과 동일하지만 기본 이름 대신에 객체 타입을 사용한다. 

중첩된 객체 타입을 고유 타입 이름으로 바꿔서 사용하면 코드와 오류 메시지가 더 읽기 쉬워진다.

### 4.2.4 선택적 속성

타입의 속성 애너테이션에서 ? 를 추가하면 선택적 속성임을 나타낼 수 있다. 

## 4.3 객체 타입 유니언

타입스크립트 코드에서는 속성이 조금 다른, 하나 이상의 서로 다른 객체 타입이 될 수 있는 타입임을 설명할 수 있어야 한다. 또한 속성 값을 기반으로 해당 객체 타입 간에 타입을 좁혀야 할 수도 있다.

### 4.3.1 유추된 객체 타입 유니언

변수에 여러 객체 타입 중 하나가 될 수 있는 초깃값이 주어지면 타입스크립트는 해당 타입을 객체 타입 유니언으로 유추한다. 유니언 타입은 가능한 각 객체 타입을 구성하고 있는 요소를 모두 가질 수 있다. 객체 타입에 정의된 각각의 가능한 속성은 비록 초깃값이 없는 선택적 타입이지만 각 객체 타입의 구성요소로 주어진다. 

### 4.3.2 명시된 객체 타입 유니언

객체 타입의 조합을 명시하면 객체 타입을 더 명확히 정의할 수 있다. 특히 값의 타입이 객체 타입으로 구성된 유니언이라면 타입스크립트의 타입 시스템은 이런 유니언 타입에 존재하는 속성에 대한 접근만 허용한다. 

### 4.3.3 객체 타입 내로잉

입 검사기가 유니언 타입 값에 특정 속성이 포함된 경우에만 코드 영역을 실행할 수 있음을 알게 되면, 값의 타입을 해당 속성을 포함하는 구성 요소로만 좁힌다. 즉, 코드에서 객체의 형태를 확인하고 타입 내로잉이 객체에 적용된다. 

<aside>
💡 타입스크립트는 if(poem.pages)와 같은 형식으로 참 여부를 확인하는 것을 허용하지 않는다. 존재하지 않는 객체의 속성에 접근하려고 시도하면 타입 가드처럼 작동하는 방식으로 사용되더라도 타입 오류로 간주된다.

</aside>

### 4.3.4 판별된 유니언

판별된 유니언이란 객체의 속성이 객체의 형태를 나타내도록 하는 것이다. 객체의 타입을 가리키는 속성이 판별값이다. 타입스크립트는 코드에서 판별 속성을 사용해 타입 내로잉을 수행한다.

```jsx
type a = {
	name : string
	type : 'a'
}

type b = {
	name : string,
	type : 'b'
}

type c = a | b
```

타입을 적어주는 것

## 4.4 교차타입

타입스크립트 유니언 타입은 둘 이상의 다른 타입 중 하나의 타입이 될 수 있음을 나타낸다.

자바스크립트의 런타임 | 연산자가 & 연산자에 대응하는 역할을 하는 것 처럼, 타입스크립트에서도 & 교차타입을 사용해 여러 타입을 동시에 나타낸다. 교차 타입은 일반적으로도 여러 기존 객체 타입을 별칭 타입으로 결합해 새로운 타입을 생성한다.

교차 타입은 유니언 타입과 결합할 수 있으며, 이는 하나의 타입으로 판별된 유니언 타입을 설명하는데 유용하다. 

```jsx
type c = a & b // A 타입과 B 타입 모두 포함
```

## 4.4.1 교차타입의 위험성

교차타입은 유용하지만 때로는 타입스크립트 컴파일러를 혼동시키는 방식으로 사용하기 쉽기 때문에 위험하다. 

- 긴 할당 가능성 오류

유니언 타입과 결합하는 것 처럼 복잡한 교차 타입을 만들게 되면 할당 가능성 오류 메시지는 읽기 어려워진다. 

### never

교차 타입은 잘못 사용하기 쉽고 불가능한 타입을 생성한다. 원시 타입의 값은 동시에 여러 타입이 될 수 없기 때문에 교차 타입의 구성 요소로 함께 결합할 수 없다.  두 개의 원시 타입을 함께 시도하면 never 키워드로 표시되는 never 타입이 된다. 

```jsx
type NotPossible = number & string;
```

never 키워드와 never타입은 프로그래밍 언어에서 bottom타입 또는 empty 타입을 뜻한다. 즉, 값을 가질 수 없고 참조할 수 없는 타입이라는 것이다. 

대부분의 타입스크립트 프로젝트는 never 타입을 거의 사용하지 않지만 코드에서 불가능한 상태를 나타내기 위해 가끔 등장한다.
