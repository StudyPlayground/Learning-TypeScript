자바스크립트 배열은 매우 유연하고 내부에 모든 타입을 혼합해 저장할 수 있다.

그러나 대부분의 배열은 하나의 특정 타입만 가진다. 따라서 타입스크립트는 초기 배열에 어떤 데이터 타입이 있는지 기억하고, 배열이 해당 데이터 타입에서만 작동하도록 제한한다. 

## 6.1 배열 타입

다른 변수 선언과 마찬가지로 배열을 저장하기 위한 변수는 초깃값이 필요하지 않는다. 변수는 undefinded로 시작해서 나중에 배열값을 받을 수 있다.

배열의 각 요소가 여러 선택 타입 중 하나일 수 있으면 유니언 타입을 사용한다.

```tsx
let stringOrArrayOfNumbers: string | number[] // string이거나 number배열 이거나
let arrayOfStringOrNumbers : (string | number)[] // 배열 요소가 string이거나 number인 배열**
let stringArrayOrNumberArray : string[] | number[] // string배열이거나 number배열이거나**
```

⇒ ** 두개 헷갈릴 수도?

N차원 배열은 N 개의 []를 갖는다. 타입은`(number[])[]` 로 나타낼 수 있다.  

```tsx
(number[])[]
```

### 주의 사항

타입스크립트 타입 시스템은 기술적으로 불안정하다고 알려져있다. 대부분 올바른 타입을 얻을 수 있지만, 특히 배열은 타입시스템에서 불안정하다. 기본적으로 타입스크립트는 모든 배열의 멤버에 대한 접근이 해당 배열의 멤버를 반환한다고 가정하지만, 자바스크립트에서조차도 배열의 길이보다 큰 인덱스로 배열 요소에 접근하면 undefined를 제공한다.

아래의 소스는 에러가 나지 않는다. 

```tsx
function withElements(elements: string[]){
	console.log(elements[9001].length); // 타입 오류 x
}
withElements(["It's" "over"]);
```

<aside>
💡 타입스크립트에는 배열 조회를 더 제한하고 타입을 안전하게 만드는 noUncheckedIndexedAccess플래그가 있지만 너무 엄격해서 쓰지 않는다.

</aside>

## 6.3 스프레드와 나머지 매개변수

### 6.3.1 스프레드

… 스프레드 연산자를 사용해 배열을 결합한다. 타입스크립트는 입력된 배열 중 하나의 값이 결과에 포함될 것을 인지한다.

타입스크립트는 또한 나머지 매개변수로 배열을 스프레드하는 자바스크립트 실행을 인식하고 이해 대해 타입 검사를 수행한다. 나머지 매개변수를 위한 인수로 사용되는 배열은 나머지 매개변수와 동일한 배열 타입을 가져야 한다.

```tsx
function logMarriors(greeting: string, ...names: string[]){
	for(const name of names) {
		console.log(`${greeting}, ${name}!`);
	}
}

const warriors = ['one', 'two', 'three'];
logWarriors(warriors); // ok
const numbers = [1, 2, 3];
logWarriors(numbers) // error
```

## 튜플

자바스크립트 배열은 이론 상 어떤 크기라도 될 수 있지만, 때로는 튜플이라고 하는 고정된 크기의 배열을 사용하는 것이 더 유용하다. 튜플 배열은 각 인덱스에 알려진 특정 타입을 가지며 배열의 모든 가능한 멤버를 갖는 유니언 타입보다 더 구체적이다. 튜플 타입을 선언하는 구문은 배열 리터럴처럼 보이지만 요소의 값 대신 타입을 적는다. 

자바스크립트에서는 단일 조건을 기반으로 두 개의 변수에 초깃값을 설정하는 것 처럼 한 번에 여러 값을 할당하기 위해 튜플과 배열 구조 분해 할당을 함께 자주 사용한다.

### 튜플 할당 가능성

타입스크립트에서 튜플 타입은 가변 길이의 배열 타입보다 더 구체적이로 처리된다. 즉, 가변 길이의 배열 타입은 튜플 타입에 할당할 수 없다. 

### 나머지 매개변수로서의 튜플

튜플은 구체적인 길이와 요소 타입 정보를 가지는 배열로 간주되므로 함수에 전달할 인수를 저장하는데 특히 유용하다. 타입스크립트는 …나머지 매개변수로 전달된 튜플에 정확한 타입 검사를 제공할 수 있다.

나머지 매개변수 튜플을 사용하고 싶다면 여러 번 함수를 호출하는 인수 목록을 배열에 저장해 사용할 수 있다. 

### 튜플 추론

타입스크립트는 생성된 배열을 튜플이 아닌 가변 길이의 배열로 취급한다. 배열이 변수의 초깃값 또는 함수에 대한 반환값으로 사용되는 경우, 고정된 크기의 튜플이 아니라 유연한 크기의 배열로 가정한다. 

따라서 명시적 튜플 타입과 const assertion을 사용해 튜플임을 알려줄 수 있다. 

### 명시적 튜플 타입

튜플 타입도 타입 에너테이션에 사용할 수 있다. 

### const assertion

명시적 타입 애너테이션에 튜플 타입을 입력하는 작업은 명시적 타입 애너테이션을 입력할 때와 같이 코드 변경에 따라 작성 및 수정이 필요한 구문을 추가해야 한다. 

하지만 그 대안으로 타입스크립트는 값 뒤에 넣을 수 있는 const assertion인 as const 연산자를 제공한다. const assertion은 타입스크립트에 타입을 유추할 때 읽기 전용이 가능한 값 형식을 사용하도록 지시한다. 

다음과 같이 배열 리터럴 뒤에 as const 가 배치되면 배열이 튜플로 처리되어야 함을 나타낸다.

```tsx
const unionArray = [1157, "Tomoe"]; // (string | number)[]
const readonlyTuple = [1157, "Tomoe"] as const; // readonly [1157, "Tomoe"]
```

const assertion은 유연한 크기의 배열을 고정된 크기의 튜플로 전환하는 것을 넘어, 해당 튜플이 읽기 전용이고 값 수정을 할 수 없다는 것을 나타낸다. 

실제로 읽기 전용 튜플은 함수 반환에 편리하다. 튜플을 반환하는 함수로부터 반환된 값은 보통 즉시 구조화되지 않기 때문에 읽기 전용인 튜플은 함수를 사용하는데 방해가 되지 않는다. 

```tsx
function firstCharAndSizeAsConst(input: string) {
	return [input[0], input.length] as const;
}
const [firstChar, size] = firstCharAndSizeAsConst("Ching Shih");
```
