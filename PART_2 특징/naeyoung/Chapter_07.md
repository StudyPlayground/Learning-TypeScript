인터페이스는  별칭으로 된 객체 타입과 유사하지만 일반적으로 더 읽기 쉬운 오류 메시지, 더 빠른 컴파일러 성능, 클래스와의 더 나은 운용성을 위해 선호된다.

## 7.1 타입 별칭 vs 인터페이스

|  | 인터페이스 | 타입 |
| --- | --- | --- |
| 병합 | 가능
전역 인터페이스 또는 npm 패키지와 같은 외부 코드를 사용할 때 유용 | 불가능 |
| 클래스 선언 구조 타입 | 확인 가능 | 불가능 |
| 작동 시간 | 더 빠른 작동 | 상대적으로 느린 작동? |
| 오류 메시지 | 더 쉽게 읽을 수있음? |  |

가능하다면 인터페이스 사용을 추천한다. 즉, 타입 별칭의 유니언 타입과 같은 기능이 필요할 때 까지는 인터페이스를 사용하는 것이 좋다고 이야기한다. 

## 7.2 속성 타입

getter 와 setter를 포함해 가끔 존재하는 속성, 또는 임의의 속성 이름을 사용하는 등 자바스크립트 객체를 실제로 사용할 때 낮설고 이상할 수 있다. 타입스크립트는 인터페이스가 이런 이상한 부분을 모델링할 수 있도록 유용한 타입시스템 도구를 제공한다.

### 7.2.1 선택적 속성

타입 애너테이션 앞에? 를 사용해 인터페이스의 속성이 선택적 속성임을 나타낼 수 있다. 

### 7.2.2 읽기 전용속성

경우에 따라 인터페이스에 정의된 객체의 속성을 재할당하지 못하도록 인터페이스 사용자를 차단하고 싶을 때에는 readoly 키워드를 추가해 다른 값으로 설정할 수 없도록 만든다.

readonly 제한자는 타입시스템에만 존재하며 **인터페이스에서만 사용할  수 있다**. **readonly 제한자는 객체의 인터페이스를 선언하는 위치에서만 사용되고 실제 객체에는 적용되지 않는다.**

### 7.2.3 함수와 메서드

- 메서드 구문 : 인터페이스 멤버를 member() : void 같이 객체의 멤버로 호출되는 함수로 선언
- 속성 구문: 인터페이스의 멤버를 member : () ⇒ void와 같이 독립 함수와 동일하게 선언

두 가지 선언 방법은 자바스크립트에서 객체를 함수로 선언하는 방법과 동일하다. 

```tsx
interface HasBothFunctionTypes {
	property: () => string
	method() : string;
}

const hasBoth: HasBothFunctionTypes = {
    property : () => "",
    method() {
        return "";
    }
}
```

옵셔널 프로퍼티

```tsx
interface HasBothFunctionTypes {
	property?: () => string
	method?() : string;
}
```

메서드와 속성 선언은 대부분 서로 교환해 사용할 수 있다. 

- 메서드는 readonly로 선언할 수 없지만 속성은 가능하다
- 인터페이스 병합은 메서드와 속성을 다르게 처리한다.
- 타입에서 수행되는 일부 작업은 메서드와 속성을 다르게 처리한다.

타입스크립트의 향후 버전에서는 메서드와 속성의 차이점에 대해 더 엄격한 옵션을 추가할 지도 모른다.

현 시점에서 추천하는 스타일 가이드는 다음과 같다. 

- 기본 함수가 this를 참조할 수 있다는 것을 알고 있다면 메서드 함수를 사용. 클래스의 인스턴스에서 사용된다.
- 반대의 경우에는 속성을 사용

### 7.2.4 호출 시그니처

인터페이스와 객체 타입은 호출 시그니처로 선언할 수 있다. 호출 시그니처는 값을 함수처럼 호출하는 방식에 대한 타입시스템의 설명이다. 호출 시그니처가 선언한 방식으로 호출되는 값만 인터페이스에 할당할 수 있다. 

즉, 할당 가능한 매개변수와 반환 타입을 가진 함수이다. 호출 시그니처는 함수 타입과 비슷하지만 콜론 대신 화살표(⇒)로 표시한다.

```tsx
type FunctionAlias = (input: string) => number;
interface CallSignature {
	(input: string) : number;
}

const typedFunctionAlias : FunctionAlias = (input) => input.length;
const typedCallSignature: CallSignature = (input) => input.length;
```

호출 시그니처는 사용자 정의 속성을 추가로 갖는 함수를 설명하는 데 사용할 수 있다. 타입스크립트는 함수 선언에 추가된 속성을 해당 함수 선언의 타입에 추가하는 것으로 인식한다. 

### 7.2.5 인덱스 시그니처

일부 자바스크립트 프로젝트는 임의의 string 키에 값을 저장하기 위한 객체를 생성한다. 이러한 컨테이너 객체의 경우 모든 가능한 키에 대해 필드가 있는 인터페이스를 선언하는 것은 비현실적이거나 불가능하다.

타입스크립트는 인덱스 시그니처 구문을 제공해 인터페이스의 객체가 임의의 키를 받고, 해당 키 아래의 특정 타입을 반환할 수 있음을 나타낸다. 자바스크립트 객체 속성 조회는 암묵적으로 키를 문자열로 변환하기 때문에 인터페이스의 객체는 문자열 키와 함께 가장 일반적으로 사용한다. 

인덱스 시그니처는 일반 속성 정의와 유사하지만 키 다음에 타입이 있고 `{[i: string]: ...} 과 같이 배열의 대괄호를 갖는다. 

인덱스 시그니처는 객체에 값을 할당할 때 편리하지만 타입 안정성을 완벽하게 보장하지는 않는다. 인덱스 시그니처는 객체가 어떤 속성에 접근하든 간에 값을 반환해야 함을 나타낸다.

따라서 키/값 쌍을 저장하려고 하는데 키를 미리 알 수 없다면 Map을 사용하는 편이 더 안전하다.

.get 메서드는 항상 키가 존재하지 않음을 나타내기 위해 | undefined 타입을 반환한다. 

### 속성과 인덱스 시그니처 혼합

인터페이스는 명시적으로 명명된 속성과 포괄적인 용도의 string 인덱스 시그니처를 한번에 포함할 수 있다. 각각의 명명된 속성의 타입은 포괄적인 용도의 인덱스 시그니처로 할당할 수 있어야 한다. 

명명된 속성이 더 구체적인 타입을 제공하고, 다른 속성은 인덱스 시그니처의 타입으로 대체하는 것으로 혼합해 사용할 수 있다.
