# CHAPTER 14 구문 확장

- 타입스크립트와 같은 상위 집합 언어에 특정 새로운 런타임 기능으로 자바스크립트 구문을 확장하는 방식은 다음과 같은 이유로 인해 나쁜 사례로 간주합니다.
  - 런타임 구문 확장이 최신 버전 자바스크립트의 새로운 구문과 충돌할 수 있다는 점이 가장 중요합니다.
  - 언어를 첨음 접하는 프로그래머가 자바스크립트가 끝나는 곳과 다른 언어가 시작하는 곳을 이해하기 어렵게 만듭니다.
  - 상위 집합 언어 코드를 사용하고 자바스크립트를 내보내는 트랜스파일러의 복잡성을 증가시킵니다.

## 14.1 클래스 매개변수 속성

- 타입스크립트는 매개변수 속성을 선언하기 위한 단축 구문을 제공합니다. 속성은 클래스 생성자의 시작 부분에 동일한 타입의 멤버 속성으로 할당됩니다. 생성자의 매개변수 앞에 readonly 또는 public, protected, private 제한자 중 하나를 배치하면 타입스크립트가 동일한 이름과 타입의 속성도 선언하도록 지시합니다.
- 매개변수 속성은 새로운 `#` 클래스 private 필드 구문과 함께 사용할 수 없습니다.
- 클래스 생성을 매우 선호하는 프로젝트에서는 매개변수 속성을 사용하면 정말 좋습니다.

## 14.2 실험적인 데코레이터

- 클래스를 포함하는 많은 다른 언어에서는 클래스와 클래스의 멤버를 수정하기 위한 일종의 런타임 로직으로 주석을 달거나 데코레이팅할 수 있습니다.
- ECMA스크립트에서는 아직 데코레이터를 승인하지 않았으므로 타입스크립트 버전 4.7.2에서는 기본적으로 데코레이터를 지원하지 않습니다. 그러나 타입스크립트는 데코레이터의 오랜된 실험적인 버전을 코드에서 사용할 수 있도록 제공하는 experimentalDecorators 컴파일러 옵션을 제공합니다.
  - tsc CLI 또는 TSConfig를 통해 활성화할 수 있습니다.

## 14.3 열거형

- 자주 반복되는 리터럴 집합이 있고, 그 리터럴 집합을 공통 이름으로 설명할 수 있으며, 열거형으로 전환했을 때 훨씬 더 읽기 쉽지 않은 경우라면 열거형을 사용해서는 안 됩니다.
- 자바스크립트는 열거형 구문을 포함하지 않으므로 열거형을 배치해야 하는 곳에 일반적인 객체를 사용합니다.
- 타입스크립트에서 열거형 같은 객체를 사용할 때 까다로운 점은 값이 해당 객체의 값 중 하나여야 함을 나타내는 훌륭한 타입 시스템 방법이 없다는 것입니다. 한 가지 일반적인 방법은 9장 ‘타입 제한자’의 keyof와 typeof 타입 제한자를 함께 사용해 하나의 값을 해킹하는 것이지만, 이렇게 하려면 상당한 양의 구문을 입력해야 합니다.
- ‘자바스크립트에 새로운 런타임 구문 구조를 절대 추가하지 않는다’는 타입스크립트의 일반적인 만트라`mantra`를 위반합니다.
- 자동 숫잣값
  - 값이 생략되면 첫번째 값을 0으로 시작하고 각 후속 값을 1씩 증가시킵니다.
  - 숫잣값이 있는 열거형에서 명시적 값을 갖지 않는 모든 멤버는 이전 값보다 1 더 큰 값을 갖습니다.
- 문자열값을 갖는 열거형
  - 문자열값을 갖는 열거형은 읽기 쉬운 이름으로 공유 상수의 별칭을 지정하는 데 유용합니다.
  - 문자열값의 한 가지 단점은 타입스크립트에 따라 자동으로 계산할 수 없다는 것입니다. 숫잣값이 있는 멤버 뒤에 오는 열거형 멤버만 자동으로 계산할 수 있습니다.
- const 열거형
  - 타입스크립트는 const 제한자로 열거형을 선언해 컴파일된 자바스크립트 코드에서 객체 정의와 속성 조회를 생략하도록 지시합니다.
    ```tsx
    const enum DisplayHint {
      Opaque = 0,
      Semitransparent,
      Transparent,
    }

    let displayHint = DisplayHint.Transparent;
    ```
  - 컴파일된 자바스크립트 코드에는 열거형 선언이 모두 누락되고 열거형의 값에 대한 주석을 사용합니다.
    ```tsx
    let displayHint = 2; /* DisplayHint.Transparent */
    ```

## 14.4 네임스페이스

- 기존 패키지에 대한 DefinitelyTyped 타입 정의를 작성하지 않는 한 네임스페이스를 사용하지 마세요. 네임스페이스는 최신 자바스크립트 모듈 의미 체계와 일치하지 않습니다. 자동 멤버 할당은 코드를 읽는 것을 혼란스럽게 만들 수 있습니다. .d.ts 파일에서 네임스페이스를 접할 수 있기 때문에 이번 절에서 언급할 뿐입니다.
- 타입스크립트 언어는 지금은 네임스페이스라 부르는 내부 모듈 개념을 가진 하나의 해결책을 제공했습니다. 네임스페이스는 객체의 멤버로 호출할 수 있는 내보낸 콘텐츠가 있는, 전역으로 사용 가능한 객체입니다. 네임스페이스는 namespace 키워드와 {} 코드 블록으로 정의합니다. 네임스페이스 블록의 모든 코드는 함수 클로저 내에서 평가됩니다.
- 네임스페이스 내보내기
  - 네임스페이스를 유용하게 만드는 핵심 기능은 콘텐츠를 네임스페이스 객체의 멤버로 만들어 내보내는 기능입니다.
  - 네임스페이스가 여러 파일에 걸쳐 분할되어 작성되었더라도 아주 잘 작동합니다.
    ```tsx
    // setting/constants.ts
    namespace Settings {
      export const name = "My Application";
      export const version = "1.2.3";
    }

    // setting/describe.ts
    namespace Settings {
      export function describe() {
        return `${Settings.name} at version ${Settings.version}`;
      }
    }
    ```
  - 네임스페이스를 사용할 때의 주요 차이점은 서로 다른 파일로 분할될 수 있고 멤버가 네임스페이스의 이름으로 여전히 참조할 수 있다는 점입니다.
- 중첩된 네임스페이스
  - 네임스페이스는 다른 네임스페이스 내에서 네임스페이스를 내보내거나 하나 이상의 마침표를 사용해서 무한으로 중첩할 수 있습니다.
    ```tsx
    namespace Root.Nested {
      export const value1 = true;
    }

    namespace Root {
      export namespace Nested {
        export const value2 = true;
      }
    }
    ```
- 타입 정의에서 네임스페이스
  - 많은 브라우저 지원 자바스크립트 라이브러리는 더 현대적인 모듈 시스템에 삽입되고 전역 네임스페이스를 생성하기 위해 설정됩니다. 타입스크립트는 모듈 타입 정의에 export as namespace와 그 뒤에 전역 이름을 포함하고, 해당 이름을 사용해서 모듈을 전역으로 사용할 수 있음을 나타냅니다.
    ```tsx
    // node_modules/@types/my-example-lib/index.d.ts
    export const value: number;
    export as namespace libExample;

    // src/index.ts
    import * as libExample from "my-example-lib";
    const value = window.libExample.value;
    ```
  - 네임스페이스보다 모듈을 선호함
    - 네임스페이스로 구조화된 타입스크립트 코드는 웹팩과 같은 최신 빌더에서 사용하지 않는 파일을 제거하는 것이 쉽지 않습니다. 네임스페이스는 ECMA스크립트 모듈처럼 파일 간에 명시적으로 선언되는 게 아니라 암시적으로 연결을 생성하기 때문입니다.

## 14.5 타입 전용 가져오기와 내보내기

- 한 번에 하나의 파일에서 작동하는 바벨 같은 트랜스파일러는 각 이름이 타입 시스템에서만 사용되는지 여부를 알 수 있는 타입스크립트 타입 시스템에 접근할 수 없습니다. 13장 ‘구성 옵션’에서 다룬 타입스크립트의 isolatedModules 컴파일러 옵션은 코드가 타입스크립트가 아닌 다른 도구에서 변환되는 지 확인할 때 매우 유용합니다.
- 타입스크립트는 export와 import 선언에서 개별적으로 가져온 이름 또는 전체 객체 앞에 type 제한자를 추가할 수 있습니다. 이렇게 하면 타입 시스템에서만 사용된다는 것을 나타냅니다.
  ```tsx
  //index.ts
  import { type TypeOne, value } from "my-example-types";
  import type { TypeTwo } from "my-example-types";
  import type DefaultType from "my-example-types";
  ```

## 14.6 마치며
