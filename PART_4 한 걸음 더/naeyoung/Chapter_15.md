# CHAPTER 15 타입 운영

### 15.1 매핑된 타입

타입스크립트는 다른 타입의 속성을 기반으로 새로운 타입을 생성하는 구문을 제공한다. 즉, 하나의 타입에서 다른 타입으로 매핑한다. 

타입스크립트의 매핑된 타입은 다른 타입을 가져와 해당 타입의 각 속성에 대해 일부 작업을 수행하는 타입이다. 매핑된 타입은 키 집합의 각 키에 대한 새로운 속성을 만들어 새로운 타입을 생성한다. 

매핑된 타입은 키 집합의 각 키에 대한 새로운 속성을 만들어 새로운 타입을 생성한다. 매핑된 타입은 인덱스 시그니처와 유사한 구문을 사용하지만 [i : string] 과 같이 :를 사용한 정적 키 타입을 사용하는 대신 [K in OriginalType]과 같이 in을 사용해 다른 타입으로부터 **계산된 타입을 사용한다.**

### A in B

```tsx
type NewType = {
	[K in OriginalType]: NewProperty;
}
```

매핑된 타입에 대한 일반적인 사용 사례는 유니언 타입에 존재하는 각 문자열 리터럴 키를 가진 객체를 생성하는 것이다. 

```tsx
type Animal = "alligatior" | "baboon" | "cat"
type AnialCounts = {
	[K in Animals] : number;
}
```

존재하는 유니언 리터럴을 기반으로 하는 매핑된 타입은 큰 인터페이스를 선언하는 공간을 절약하는 편리한 방법이다. 하지만 매핑된 타입은 타른 타입에 대해 작동하고 멤버에서 제한자를 추가하거나 제거할 때 유용해진다.

### 15.1.1 타입에서 매핑된 타입

일반적으로 매핑된 타입은 존재하는 타입에 keyof 연산자를 사용해 키를 가져오는 방식으로 작동한다. 존재하는 타입의 키를 매핑하도록 타입에 지시하면 새로운 타입으로 매핑한다. 

다음 AnimalCounts 타입은 AnimalVariant 타입에서 이와 동등한 새로운 타입으로 매핑되고, 결국 이전의 AniamlCounts와 동일해진다 

### keyof

```tsx
interface AniamlVariants {
	alligator : boolean;
	baboon : number;
	cat : string;
}

type AnimalCounts = {
	[K in keyof AnimalVariants] : number;
}
```

이전 스니펫에서 K로 명명된 keyof에 매핑된 새로운 타입 키는 원래 타입의 키로 알려져 있다. 

원본 객체가 SomeName이고 매핑이 [K in keyof SomeName] 이라면 매핑된 타입의 각 멤버는 SomeName[K] 로 참조할 수 있다.

다음 NullableBirdVariants 타입은 원본 BirdVariants 타입을 사용해 각 멤버에 | null을 추가한다

```tsx
interface BirdVariants {
	dove : string;
	eagle : boolean;
}

type NullableBirdVariants = {
	[K in keyof BirdVariants] : BirdVariants[K] | null;
}
```

각 필드를 원본 타입에서 임의의 수의 다른 타입으로 어렵게 복사하는 대신, 매핑된 타입은 멤버 집합을 한 번 정의하고 필요한 만큼 여러 번 새로운 버전을 다시 생성할 수 있다.

### 매핑된 타입과 시그니처

인터페이스 멤버를 함수를 선언하는 두 가지 방법

- member() : void 같은 메서드 구문 : 인터페이스의 멤버가 객체의 멤버로 호출되도록 의도된 함수임을 선언
- member : () ⇒ void 같은 속성 구문 : 인터페이스의 멤버가 독립 실행형 함수와 같다고 선언

매핑된 타입은 객체 타입의 메서드와 속성 구문을 구분하지 않는다. 매핑된 타입은 메서드를 원래 타입의 속성으로 취급한다. 

대부분의 실용적인 타입스크립트 코드에서 메서드와 속성의 차이는 잘 나타나지 않는다. 클래스 타입을 갖는 매핑된 타입을 실제로 사용하는 경우는 매우 드믄문 일이다.

### 15.1.2 제한자 변경

매핑된 타입은 원래 타입의 멤버에 대해 접근 제어 제한자인 readonly 와 ?도 변경가능하다. 전형적인 인터페이스와 동일한 구문을 사용해 매핑된 타입의 멤버에 readonly와 ? 를 배치할 수 있다. 

### 15.1.3 제네릭 매핑된 타입

매핑된 타입은 제네릭과 결합해 단일 타입의 매핑을 다른 타입에서 재사용할 수 있도록 하는 것에서 나온다. 

매핑된 타입은  핑된 타입 자체의 타입 매개변수를 포함해 keyof로 해당 스코프에 있는 모든 타입 이름에 접근할 수 있다.

제네릭 매핑 타입은 데이터가 애플리케이션을 통해 흐를 때 데이터가 어떻게 변형되는지 나타날 때 유용하다. 예를 들어, 어플리케이션 영역이 기존 타입의 값을 가져올 수는 있지만 데이터를 수정하는 것은 허용하지 않는 것이 좋다.

또 다른 예로는, 임의의 수의 인터페이스를 받고, 그 인터페이스의 완전히 채워진 인스턴스를 반환하는 함수이다. 

```tsx
type MakeOptional<T> = {
    [K in keyof T]? : T[K]
}

interface GenusData {
    family : string,
    name : string,
}

function setGenusData (overides?: MakeOptional<GenusData>) : GenusData {
    return {
        family : '',
        name : '',
        ...overides
    }
}

// util type partial 과 같음
```

### 15.2 조건부 타입

기존 타입을 다른 타입에 매핑하는 것은 좋지만, 타입시스템에 논리적 조건이 추가되지 않았다. 

타입스크립트의 타입 시스템은 논리 프로그래밍 언어의 예이다. 

타입스크립트의 타입 시스템은 이전 타입에 대한 논리적인 검사를 바탕으로, 새로운 구성을 생성한다. 조건부 타입의 개념은 기존 타입을 바탕으로 두 가지 가능한 타입 중 하나로 확인되는 타입이다. 

조건부 타입 구문은 삼항 연산자 조건문 처럼 보인다.

```tsx
LeftType extends RightType ? IfTrue : IfFalse
```

조건부 타입에서 논리적 검사는 항상 extend의 왼쪽 타입이 오른쪽 타입이 되는 지 또는 할당 가능 여부에 있다. 

### 15.2.1 제네릭 조건부 타입

조건부 타입은 조건부 타입 자체의 매개변수를 포함한 해당 스코프에서 모든 타입 이름을 확인할 수 있다.

즉, 모든 다른 타입을 기반으로 새로운 타입을 생성하기 위해 재사용 가능한 제네릭 타입을 작성할 수 있다 

```tsx
type CallableSetting<T> = T extends () => any ? T : () => T;

// T를 받고, T가 함수인지 아닌지 확인 한 뒤 함수이면 T가 되고 아니면 T를 리턴하는 함수로 만든다.

type GetNumberSetting = CallableSetting<() => number[]>
type StringSetting = CallableSetting<string>;
```

조건부 타입은 객체 멤버 검색 구문을 사용해 제공된 타입의 멤버에 접근할 수 있고, extends 결과 타입에서 그 정보를 사용할 수 있다.

자바스크립트 라이브러리에서 사용하는 패턴 중 조건부 제네릭 타입에도 적합한 한 가지 패턴은 함수에 제공된 옵션 객체를 기반으로 함수의 반환 타입을 변경하는 것이다. 

예를 들어, 대부분의 데이터베이스 함수나 이와 동등한 함수는 값을 찾을 수 없는 경우 undefined를 반환하는 대신 `throwIfNotFound` 와 같은 속성을 사용해 함수가 오류를 발생시키도록 변경할 수 있다.

### 타입 분산

조건부 타입은 유니언에 분산된다. 결과 타입은 각 구성 요소에 조건부 타입을 적용하는 유니언이 됨을 의미한다. 즉, ConditialType<T | U>는 Condtianal<T> | Conditianal<U>와 같다.

### 유추된 타입

제공된 타입의 멤버에 접근하는 것은 타입의 멤버로 저장된 정보에 대해서는 잘 작동하지만, 함수 매개변수 또는 반환 타입과 같은 다른 정보에 대해서는 알 수 없다. 조건부 타입은 extends절에 infer키워드를 사용해 조건의 임의의 부분에 접근한다. extends절에 타입에 대한 infer 키워드로 사용할 수 있다. 

### 매핑된 조건부 타입

매핑된 타입은 기존 타입의 모든 멤버에 변경사항을 적용하고 조건부 타입은 하나의 기존 타입에 변경 사항을 적용한다. 

### never과 매핑된 타입
